/** \file
 * 		Map.hpp
 *
 *  \brief
 *  	Classes and functions to represent a 2d game map
 *
 *  \detail
 * 		Defines everything related to the representation of
 * 		a 2d game map and and infrastructure needed for
 * 		graph expansion done by AStar (or similar algorithm).
 * 		For details see documentation of class Map
 *
 *  \version
 *  	2018-10-10 ipsch: 1.0.0 final
 *
 *  \authors
 *  	ipsch: Ingmar Schnell
 *      contact: i.p.schnell(at)gmail.com
 */

#pragma once
#ifndef MAP_HPP_
#define MAP_HPP_


#include <iostream>      // printing result of LoadMap to screen
#include <fstream>       // handling files
#include <sstream>       // translate built-in types to string
#include <string>        // strings for filenames & output to cout
#include <cmath>         // fabs(..) & abs(..)
#include <stdexcept>     // exception handling
#include "oString.hpp"   // find & replace for std::string
#include "ListLIFO.hpp"  // simple list to store map nodes temporary

namespace o_graph
{



	/** \brief Representation of a single Graph/Map Node to be used in informed pathfinding algorithm
	 */
	class MapNode
	{
	public :
		MapNode() : id_(0), fvalue_(0), path_cost_(0), p_predecessor_(0L) { }
		unsigned int id_;         //< unique id for identifying
		float fvalue_;            //< fvalue calculated from heuristic and pathcost
		int path_cost_;           //< for tracking pathcost
		MapNode *p_predecessor_;  //< Pointer to predecessor (node was expanded by predecessor)

		// operators for oder relations
		inline bool operator>(const MapNode &rhs) const {
			return this->fvalue_>rhs.fvalue_;}
		inline bool operator<(const MapNode &rhs) const {
			return this->fvalue_<rhs.fvalue_;}
		inline bool operator>=(const MapNode &rhs) const {
			return this->fvalue_>=rhs.fvalue_;}
		inline bool operator<=(const MapNode &rhs) const {
			return this->fvalue_<=rhs.fvalue_;}
		inline bool operator==(const MapNode &rhs) const {
			return this->fvalue_==rhs.fvalue_;}

		MapNode &operator=(const MapNode &rhs)
		{
			id_ = rhs.id_;
			fvalue_ = rhs.fvalue_;
			path_cost_ = rhs.path_cost_;
			p_predecessor_ = rhs.p_predecessor_;
			return *this;
		}
	};


	/** \brief Representation of a 2d game map
	 *
	 * 	\detail Maps Properties:
	 * 	- uniform square grid map (inter node distance == 1)
	 * 	- Movement is allowed horizontally and vertically but not diagonally
	 * 	- constant movement cost (inter node cost == 1)
	 * 	- modified manhattan heuristics:
	 * 	  - sum of distance to reference point (aka target) and
	 * 	    small deviation in the range from (0, 1.)
	 * 	  - deviation: (distance)/(supremum of manhattan distance)
	 *
	 *  \detail To keep in mind when using with pathfinder class:
	 *  - Map size mustn't change after initialization
	 *  - for every new pathfinding attempt the heuristic needs to be
	 *    set to the targets position as point of reference
	 */
	class Map
	{

	public :
		Map(const Map &map);
		explicit Map(const int &width, const int &height, const unsigned char *data);

		/** \brief calculates the id of a node from its position on the grid
		 *  \param[in] x The nodes x-coordinate
		 *  \param[in] y The nodes y-coordinate
		 *  \return The nodes id
		 */
		inline int get_id(const int &x, const int &y) const {
			return x + y*width_;
		}

		/** \brief checks if the map is traversable at a certain position
		 *  \param[in] x-coordinate of the position
		 *  \param[in] y-coordinate of the position
		 *  \return true if map is traversable at (x,y); false otherwise
		 */
		inline bool is_traversable(const int &x, const int &y) const {
			return (operator()(x,y) == Map::terrain_traversable_);
		}

		void fill_neighbour_list(const MapNode * node);
		void set_heuristic(const int &x0, const int &y0);
		double get_heuristic(const unsigned int &id) const;

		typedef o_data_structures::ListLIFO<unsigned int, 4> TypNeighbourList;
		const int width_;                  //< The maps width (extent in x-direction)
		const int height_;                 //< The maps height (extent in y-direction)
		const unsigned char *data_;        //< Pointer to Maps bulk data (grid information)
		TypNeighbourList neighbour_list_;  //< Stores ids generated by fill_neighbour_list(..)

	protected :

		Map();

		int x0_;                                          //< Reference x-coordinate fot the heuristic (== targets x-value)
		int y0_;                                          //< Reference y-coordinate for the heuristic (== targets y-value)
		const float max_manhattan_;                      //< supremum of the manhattan norm on this map
		static const unsigned char terrain_traversable_;  //< symbol to indicate a traversable map node
		static const unsigned char terrain_blocked_;      //< symbol to indicate a blocked map node

		/** \brief calculates a nodes x-coordinate from its id
		 *  \param[in] id The nodes id
		 *  \return The nodes x-coordinate
		 */
		inline int get_x(const unsigned int &id) const {
			return id % width_;
		}

		/** \brief calculates a nodes y-coordinate from its id
		 *  \param[in] id The nodes id
		 *  \return The nodes y-coordinate
		 */
		inline int get_y(const unsigned int &id) const {
			return id / width_;
		}


		/** \brief accesses (rvalue) bulk data of the map at a certain position
		 *  \param[in] x-coordinate of the position
		 *  \param[in] y-coordinate of the position
		 *  \return terrain symbol associated with (x,y)
		 */
		inline unsigned char operator()(const int &x, const int &y) const {
			return data_[x + y*width_];
		}

		friend Map LoadMap(const std::string &path_to_file);
		friend void PrintMap(const Map &map, std::ostream &output_stream);
	};


	void PrintMap(const Map &map, std::ostream &output_stream = std::cout);

	Map LoadMap(const std::string &path_to_file);

} // END OF NAMESPACE o_graph

#endif // END OF MAP_HPP_


